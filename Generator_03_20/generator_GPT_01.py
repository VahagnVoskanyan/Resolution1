import random

# Example symbol sets
PREDICATES = ["P", "Q", "R"]
CONSTANTS  = ["a", "b", "c"]
VARIABLES  = ["x", "y", "z"]
FUNCTIONS  = ["f", "g", "h"]  # function symbols for nesting

# Probability controls
P_NEST = 0.3  # Probability of nesting (using function) during term generation
MAX_ARITY_FUNC = 3  # Functions can have up to 3 arguments
MAX_ARITY_PRED = 3  # Predicates can have up to 3 arguments

def random_variable_or_constant():
    """
    Randomly returns either a variable or a constant with equal probability.
    """
    if random.random() < 0.5:
        return random.choice(VARIABLES)
    else:
        return random.choice(CONSTANTS)

def generate_term(max_depth=2):
    """
    Recursively generate a term that may be:
      - a variable
      - a constant
      - a function applied to subterms (with some probability of nesting, up to max_depth)
    """
    # Base case or stopping condition: if depth is 0 or random chance:
    if max_depth == 0 or random.random() > P_NEST:
        # Return variable/constant
        return random_variable_or_constant()
    
    # Otherwise, build a nested function term
    func_symbol = random.choice(FUNCTIONS)
    arity = random.randint(1, MAX_ARITY_FUNC)
    subterms = [generate_term(max_depth - 1) for _ in range(arity)]
    # Format e.g.: f(x,y) or g(a,f(x,b,z))
    return "{}({})".format(func_symbol, ",".join(subterms))

def generate_literal():
    """
    Generates a random literal of the form:
      ~? P(...terms...)
    Where:
      - 'P' is chosen from PREDICATES
      - The number of arguments is 0..MAX_ARITY_PRED
      - Each argument is generated by generate_term (with some nesting allowed)
      - There's a 50% chance the literal is negated with '~'
    """
    pred = random.choice(PREDICATES)
    arity = random.randint(0, MAX_ARITY_PRED)
    
    # Build the argument list
    args = [generate_term(max_depth=2) for _ in range(arity)]
    literal_str = pred
    if arity > 0:
        literal_str += "(" + ",".join(args) + ")"
    
    # 50% chance to negate
    if random.random() < 0.5:
        return "~" + literal_str
    else:
        return literal_str

def make_complementary(literal):
    """
    Given a literal (string), produce its logical complement:
      - If it starts with '~', remove '~'.
      - Otherwise, prepend '~'.
    """
    if literal.startswith("~"):
        return literal[1:]  # remove '~'
    else:
        return "~" + literal

def generate_clause(num_literals=3):
    """
    Generates a random clause as a list of literal strings.
    E.g.: ["~P(x,a)", "Q(f(x),b)", "R(z)"] 
    """
    return [generate_literal() for _ in range(num_literals)]

def generate_clause_pair(num_literals=3):
    """
    Generates two clauses (each a list of literal strings).
    Ensures at least one complementary literal pair among them.
    
    1) Create a random Clause A.
    2) Choose one or more literals to 'flip' and add them into Clause B 
       so that B has complementary versions of those literals. 
    3) Fill Clause B with random literals for variety.
    """
    clauseA = generate_clause(num_literals)
    
    # Let's ensure we flip at least one literal from A to make them complementary
    # We'll flip between 1 and all of them, randomly:
    num_to_flip = random.randint(1, num_literals)
    # Choose random distinct literals from Clause A
    lit_indices = random.sample(range(num_literals), num_to_flip)
    
    # Build Clause B
    clauseB = []
    # 1) Insert complementary versions of the chosen A-literals
    for idx in lit_indices:
        clauseB.append(make_complementary(clauseA[idx]))
    # 2) Fill up Clause B with random literals until it has 'num_literals' total
    while len(clauseB) < num_literals:
        clauseB.append(generate_literal())
    # Shuffle for randomness
    random.shuffle(clauseB)
    
    return clauseA, clauseB

if __name__ == "__main__":
    # Quick demonstration
    for _ in range(5):
        cA, cB = generate_clause_pair(num_literals=3)
        print("Clause A:", cA)
        print("Clause B:", cB)
        print("-----")
